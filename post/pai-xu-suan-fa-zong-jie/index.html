<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>排序算法总结 | NOTES</title>
<meta name="description" content="Life is struggle.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zhongfei2016.github.io//favicon.ico?v=1572790077634">
<link rel="stylesheet" href="https://zhongfei2016.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zhongfei2016.github.io/">
        <img src="https://zhongfei2016.github.io//images/avatar.png?v=1572790077634" class="site-logo">
        <h1 class="site-title">NOTES</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            分类
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Life is struggle.
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a><b> | </b><a href="https://zhongfei2016.github.io" target="_blank">zhongfei</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">排序算法总结</h2>
            <div class="post-date">2019-09-08</div>
            
            <div class="post-content">
              <p>排序方法有快速排序、希尔排序、归并排序、插入排序、选择排序、冒泡排序等。</p>
<h2 id="排序稳定性"><strong>排序稳定性</strong></h2>
<p>排序前后在序列里两个相等的数在序列中原始的前后位置顺序，在排序后不发生改变，即排序前，ai=aj，且ai在aj之前，则排序后，ai仍在aj之前。</p>
<p><strong>选择排序</strong>：<br>
时间复杂度O(n^2)，需要一个额外交换用空间，空间复杂度O(1)</p>
<p>从第一个开始，拿第一个和后面的每一个元素比较，第一个比后面的大就交换两者，一直比到最后一个元素，这样第一轮就找到了最小值，第二轮从第二个元素开始，以此类推。有这样的序列：a1，a2，b，当前元素a1比其后面一个元素b大，且其后面这个元素b在另一个与当前元素a1相等的元素a2后面，如果a1比b大，则a1会和b交换，原来a1在a2前面，a1和b交换后变为b，a2，a1，a1和a2顺序颠倒，所以其为不稳定排序。</p>
<p><strong>冒泡排序</strong>：<br>
需要n*(n+1)/2个循环，时间复杂度O(n^2)，需要一个额外交换用空间，空间复杂度O(1)</p>
<p>从第一个元素开始，只跟后一个元素比较，如果前一个比后一个大则两者交换，那一轮过后最大的沉到最后面，第二轮再前n-1个元素比较，找出倒数第二大的元素，以此类推，由于只是交换相邻的两个元素，相等的话不会交换，即便两个相等元素不相邻，几次交换后也会相邻且也不会交换，所以是稳定排序。</p>
<p><strong>插入排序</strong>：<br>
需要n*(n+1)/2个循环，时间复杂度O(n^2)，需要一个额外交换用空间，空间复杂度O(1)</p>
<p>将后面元素插入既定序列中（既定序列起始只有一个值），将既定序列后面拿出的待插入元素从既定序列的最后一个元素往前比较，遇到比他小或相等的就插到其后面，比如原始数组为1，5，4，8，3，2，其中开始认定1为既定序列，由于只有一个值所以天然有序，然后拿5跟1比较，由于比1大，所以不动，此时既定序列变为1，5，仍有序，然后拿4与当前既定序列比较，先跟5比，比5小，再跟1比，4遇到比他小的1要插到1后面，既定序列变为1，4，5，以此类推，此方式不改变相等元素顺序，所以是稳定排序。</p>
<p>对于规模比较小且基本有序的序列，效率很高。</p>
<p><strong>希尔排序</strong>：<br>
时间复杂度由O(n)到O(n^2)不定，一般是由增量序列决定，空间复杂度与插入类似，为O(1)</p>
<p>插入排序的一种改良方案，将序列先按增量分组，然后各组进行插入排序，逐渐增大每个分组的元素个数，直到只有一个分组为止，再进行一次插入排序，虽然插入排序本身是稳定的，但是由于跨增量分组进行，每组中相等的元素和同组其他元素比较大小不一定是否调换位置，所以会改变相等元素的相对位置，比如：</p>
<p>573154，分三组比较时，51一组，75一组，34一组，第一个5和1比较，交换了位置，7和第二个5比较，交换了位置，导致第二个5跑到了第一个5前面，即变为153574，所以不稳定，下面的举例图示比较直观：<br>
<img src="https://zhongfei2016.github.io//post-images/1567933310768.png" alt=""></p>
<p><strong>快速排序：</strong><br>
时间复杂度：可以理解为每次拆成两组，组数相当于每次×2，拆前为2<sup>0=1组，拆一次为2</sup>1=2组，假设x次后比较完所有n个元素，就是拆到最后每组一个元素，共n组，2<sup>x=n，那x=log(2)(n)，且每次要比n个元素，那就是nlog(2)(n)，即O(nlogn)，空间复杂度：快速排序使用分治方式，每次拆两组，每组都需要一个额外空间放中心值，即2</sup>x=n，x=log(2)(n)，因此它的空间复杂度为O(logn)</p>
<p>采用分治的方式，选定中心值（英文为pivot，需要理解的是中心值并不在中心位置），无序度大的数组一般取第一个值，无序度小的数组一般取随机值，然后进行分组，分组分左右两边进行，右指针右起找比中心值小的数或者直到遇到左指针，把其指向的数赋给左指针（如果直到遇到左指针都没有找到比中心值小的数，相当于把左指针指向的数赋给左指针，左指针操作与此类似），左指针左起找比中心值大的数或者直到遇到右指针，把其指向的数赋给右指针，最后把中心值赋给左右指针相遇的位置，此位置其实是本轮排序的中心位置，之后拆为左右部分继续按此排序，直到只有一个元素为止，也有一种方式为，最右侧值a[j]的下标j先从右往左找一个小于中心值的数，与当前a[i]交换，再由a[i]的下标i从左往右找一个大于中心值的数，与当前a[j]交换他们对应的值，直到j和i相遇，则交换中心值和a[i]的值，本轮结束后再按中心值拆成两边再继续按上述方式比较直到比较的两边只有一个元素为止。</p>
<p>对于稳定性，比如5 3a 6 3b，第一轮j向左找比5小的，即3b，然后i向右找比5大的，即6，交换得到5 3a 3b 6，j继续向左找到3b，i向右遇到j，5和3b交换得到3b 3a 5 6，此时3a，3b顺序打乱，所以不稳定。</p>
<p>参考：https://www.jianshu.com/p/5f38dd54b11f</p>
<p><strong>归并排序：</strong><br>
分治方式，时间复杂度O(nlogn)，需要一个与原数组同等大小的临时空间存放有序数组，空间复杂度O(n)</p>
<p>采用递归分治的方式，将原数组不断从中间拆成2组，直到拆成每组只有一个，即为天然有序，合并时，两组分别从头开始取元素比较，较小的值放到临时数组里，临时数组大小与两组待比较数组大小之和相等，比较完总有一组先比完，有剩余的一组的所有剩余值直接追加到临时数组的后面，当前两组就排序完了，然后再递归上去直到结束，由于在合并过程中只要保证相等的情况下前面序列的元素放在前面，整个迭代过程中就不会打乱相同值的顺序，所以是稳定的。</p>
<p>参考：https://www.jianshu.com/p/95c69f8e47e7</p>
<p><strong>堆排序：</strong><br>
分治方式，时间复杂度O(nlogn)，排序虽然递归，但只是用了额外一个元素空间用于交换，空间复杂度为O(1)</p>
<p>第一个元素作为根节点，如果根节点的索引是i，则其左右节点的索引为2<em>i+1和2</em>i+2，比如根节点索引为0，则其左右节点索引分别为1和2，从第一个节点开始，只要他比父节点大，就跟父节点交换，直到没有父节点或者父节点最大为止，这是一个递归过程，由于每次都是左右两个节点在比较，所以可能出现调换，比如4，5，3，3，1，7，2这个数组，5的子节点是第二个3和1，第一个3的子节点是7和2，5和第二个3和1比较都不换位置，但是第一个3和7比较会交换位置，导致两个3位置颠倒，所以是不稳定排序。<br>
<img src="https://zhongfei2016.github.io//post-images/1568427588848.png" alt=""><br>
参考：https://www.jianshu.com/p/3e1d4ed98565</p>
<p><strong>基数排序：</strong><br>
时间复杂度O(nk)，k为元素最大位数，是常数，空间复杂度维n+t，t是存放按当前位排序的临时数组，也是常数。</p>
<p>按照每个元素的个位、十位、百位依次来排序，可以定义一个二维数组，其中第一维固定大小为10，即0~9，代表每一位可能的十个数字，第二维则设置大小为有所有元素个数，因为最大可能就是待排序的数组所有的元素某一位都相同，比如待排序数组为1，21，51，41，那二维数组为arr[10][4]，按个位排序时，arr[1]这一维是满的，因为所有四个数字个位都是1，所以都放到这一维中，即arr[1][0]=1，arr[1][1]=21，arr[1][2]=51，arr[1][3]=41，排完之后放回原数组，虽然好像个位这一轮排序并没有效果，但是按十位再向二维数组放一遍，就会得到结果了，十位的二维数组放置结果是arr[0][0]=1，arr[2][0]=21，arr[4][0]=41，arr[5][0]=51，这时候再按顺序拿出来，就已经是排好序的了，如果相同位数有多个值，比如还有个55，由于个位排序时55在arr[5][4]这里，所以放回原数组的时候，55也在51后面，按十位排序的时候，arr[5]这一维就会是天然保证arr[5][0]=51，arr[5][1]=55，此时放回原数组的时候顺序也是对的。对于两个相同的值，不论比较哪一维都会放在二维数组同一维前后位置，且顺序也会原始数组相同，不会交换，所以是稳定排序。<br>
参考：https://www.jianshu.com/p/8340dfaea3af</p>
<p><strong>各排序复杂度一览</strong><br>
<img src="https://zhongfei2016.github.io//post-images/1568427630041.png" alt=""></p>
<p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法，其实综合来看，只要存在跨增量互换的排序，都是不稳定的排序，而单纯的相邻互换，或者插入排序，都是稳定的排序。</p>
<p>稳定性总结可以参考：https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html</p>
<h2 id="各排序方法使用场景">各排序方法使用场景：</h2>
<p>当应用到已经排序好的或者基本排序好的数组上时，归并排序的时间复杂度最低。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zhongfei2016.github.io//tag/gMhaodpAd" class="tag">
                    算法基础
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zhongfei2016.github.io//post/hbase-an-zhuang-ce-shi-ru-shou">
                  <h3 class="post-title">
                    HBase安装测试入手
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
